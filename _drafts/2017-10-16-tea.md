---
layout: post
category: blog
published: false
title: TEA
---
장점 :

1. 단일 지점에서 상태, UI 액션, 외부 효과를 관리.
2. 함수형 프로그래밍적인 상태 관리
3. UI 액션이 명시적으로 선언되며 단일 지점에서 관리된다.



Msg - All events happening during interaaction with UI

Cmd - Side effect to execute

fun Update(msg: Msg, state: State) : Pair<State,Cmd> 

fun render(state: State) (fun View(state: State) : HTML in Elm)

void Init(State);



1. update program state and return the new state and command
   update(msg, state);
2. draw UI
   render(state);
3. send a new msg if any
   loop();
4. if any cmd, execute side effect
   call(cmd);
   if there is an error in side effect, send Error msg with failed command,
   which we can handle in Update function
   .onErrorResumeNext {Single.just(ErrorMsg(err, cmd))}
5. if any message , add msg to queue



Simple Elm runtime in java

    // Client
    elmRuntime.accept(userInteractionMsg);
    
    // ElmRuntime
    State currentState;
    
    void accect(Msg msg) {
      // Update state
      Pair<State, Cmd> newStateAndCmd = update(msg, currentState);
        
      // Draw UI
      State newState = newStateAndCmd.first;
      render(newState);
        
      // Do side effect
      Cmd cmd = newStateAndCmd.second;
      if (cmd != null) {}
        Msg msg = call(cmd);
        if (msg != null) {
          accept(msg);
        }
      }
    }



Taming2

....

RxJava에 익숙하다면 여기서 어려운 점은 없을 것이다. Init 함수는 초기 상태와 콜백을 처리할 Component를 받는다. 그 뒤 사이클-Update, Render, Call-을 밟아간다. Call 함수는 Single<Msg>를 반환하며 반환된 Msg가 Idle이 아니면 이 외부 효과의 Msg로 새로운 사이클을 시작하다.

큐는 메시지의 순서를 보존하기 위해 필요하다.

Call  함수를 살펴보자. 이는 일종의 Elm 런타임 에뮬레이션이다. 만약 외부 효과를 만들고 싶다면 Cmd 클래스를 상속받은 새로운 클래스를 정의하고 Call 함수에서는 이 command에 대한 결과로 나온 Msg와 페이로드를(Msg 클래스에 데이터를 담아서?) 포함한 Single 타입을 반환해야 한다.

Counter

단순한 증가 감소 프리젠터를 위한 코드는 다음과 같을 것이다.

    class IncrementDecrementPresenter(private val view: IncrementDecrementView,
      private val program: Program) : Component {
    
      data class IncrementDecrementState(val value: Int = 0) : State()
    
      class Inc : Msg()
      class Dec : Msg()
       
      var programDisposable: Disposable
    
      init {
        programDisposable = program.init(IncrementDecrementState(), this)
      }
    
      fun init() {
        program.accept(Init())
      }
    
    
      override fun update(msg: Msg, state: State): Pair<State, Cmd> {
        val state = state as IncrementDecrementState
          return when (msg) {
            is Init -> {
              Pair(state, None())
            }
            is Inc -> {
              Pair(state.copy(value = state.value+1), None())
            }    
            is Dec -> {
              Pair(state.copy(value = state.value-1), None())
            }  
            else -> Pair(state, None())
          }
      }
    
      override fun render(state: State) {
        (state as IncrementDecrementState).apply {
          view.showValue(value)
        }
      }
    
      override fun call(cmd: Cmd): Single<Msg> {
        return when (cmd) {           
          else -> Single.just(Idle())
        }
      }
    
      fun plusClick() {
        program.accept(Inc())
      }
      
      fun minusClick() {
        program.accept(Dec())
      }
      
      fun onDestroy(){
        if (!programDisposable.isDisposed()){
            programDisposable.dispose()
        }
      }
    }

이 규약은 간단하다. 함수 Init를 초기 상태와 함께 생성자(또는 생성자와 가까운 곳)에서 호출한다. 그 뒤 모든 UI 동작은 적합한 Msg와 데이터로 program.accept() 함수에 전파한다.

하지만 사실 이 예제는 우리의 관심사가 아니다. 외부 효과가 전혀 없기 때문이다! 좀 더 실제적이고 현실에 가까운 예제인 인증 화면을 보도록 하자.

Sample App

먼저 로그인 화면이 어떻게 되어야 하는지를 보자. 이 화면은 인증(authenticate)을 수행해야 하며 'Save login'이 체크되어야 한다. 그 뒤 Shared Preferences에 로그인과 패스워드를 저장해야 한다. 이후 시작시 저장된 자격(credential)을 체크할 필요할 필요가 있으며, 존재한다면 이 것으로 인증(authentication)을 만드는 것을 시도해야 한다.



이제, 이 화면을 위한 상태를 모델링해보자. 로그인과 패스워드 그 자체를 위한 필드가 필요하다. 만약 확인에 어떤 실패가 있다면 각각의 에러를 보여 주어야 하며 로그인 버튼을 비활성화하고 체크박스를 해제해야 한다. 인증 요청이 시작되면 프로그레스를 보여줘야 하며 요청이 실패하거나 성공하면 이에 대한 표시를 할 필요가 있다.

    data class LoginState(val login: String = "",
                          val loginError: String? = null,
                          val pass: String = "",
                          val passError: String? = null,
                          val saveUser: Boolean = false,
                          val isLoading: Boolean = true,
                          val error: String? = null,
                          val btnEnabled: Boolean = false,
                          val isLogged: Boolean = false) : State()

그리고 이것이 우리의 render 함수이다.

    override fun render(state: State) {
      (state as LoginState).apply {
        if (isLogged) {               
          loginView.goToMainScreen()
          return
        }
              
        if (isLoading) {
                    loginView.showProgress()
                } else {
                    loginView.hideProgress()
                }
    
                if (btnEnabled) {
                    loginView.enableLoginBtn()
                } else {
                    loginView.disableLoginBtn()
                }
    
                error?.let {
                    loginView.showError()
                    loginView.error(it)
                } ?: loginView.hideError()
    
                loginError?.let {
                    loginView.showLoginError(it)
                } ?: loginView.hideLoginError()
    
                passError?.let {
                    loginView.showPasswordError(it)
                } ?: loginView.hidePasswordError()
            }
        }

포스트의 분량을 위해 로그인 화면의 초기화에 대한 시나리오 하나만 보도록 하자. 우리는 두 가지 외부 효과가 필요하다 - Shared Preferences에서 데이터 로드와 인증을 위한 HTTP 요청.

    class GetSavedUserCmd : Cmd()
    data class LoginCmd(val login: String, val pass: String) : Cmd()

그리고 이 command들을 결과로 전달하기 위한 두 메시지.

    data class UserCredentialsLoadedMsg(val login: String, val pass: String) : Msg()
    data class LoginResponseMsg(val logged: Boolean) : Msg()

Init, Update 그리고 Call 함수는 다음과 같으며,

    fun init() {
      program.accept(Init())
    }
    
    
    override fun update(msg: Msg, state: State): Pair<State, Cmd> {
      val state = state as LoginState
      return when (msg) {
        is Init -> {
          Pair(state, GetSavedUserCmd())
        }
        is UserCredentialsLoadedMsg -> {
          Pair(state.copy(login = msg.login, pass = msg.pass), LoginCmd(msg.login, msg.pass))
        }
        is LoginResponseMsg -> {
          Pair(state.copy(isLogged = true), None())
        }
        is ErrorMsg -> {
          return when (msg.cmd) {
            is GetSavedUserCmd -> Pair(state.copy(isLoading = false), None())
            is LoginCmd -> {
              if (msg.err is RequestException) {
                return Pair(state.copy(isLoading = false, error = msg.err.error.message), None())
              }
              return Pair(state.copy(isLoading = false, error = "Error while login"), None())
            }
            else -> Pair(state, None())
          }
        }
        else -> Pair(state, None())
      }
    }
    
    override fun call(cmd: Cmd): Single<Msg> {
      return when (cmd) {
        is GetSavedUserCmd -> appPrefs.getUserSavedCredentials()
          .map { (login, pass) -> UserCredentialsLoadedMsg(login, pass) }           
        is LoginCmd -> apiService.login(cmd.login, cmd.pass)
          .map { logged -> LoginResponseMsg(logged) }
        else -> Single.just(Idle())
      }
    }

이 코드는 매우 간결하며 따라가기 쉬움을 알 수 있다.

Testing

TEA의 주요 장점 중 하나는 테스트 가능성이 믿어지지 않을 정도로 좋다는 것이다. 일반적인 MVP 앱에서 당신은 비즈니스 로직, 유스케이스 등을 테스트한다. TEA가 주는 것은 

UI와의 상호 작용을 시뮬레이션 할 수 있다.

일반적으로 Instrumentation test(또는 Espresso tests)로 했던 것을 Unit Tests로 할 수 있다.

One of the main advantages of TEA is incredible testability. In an usual MVP app you normally test business logic, Use Cases, etc. What TEA gives is the ability to test UI behaviour in connection. We can simulate interactions of user with UI by simply calling function Update -> Render -> Call one by one with necessary predefined values! What you normally do with Instrumentation tests(or Espresso tests) you can do with Unit Tests!

다음과 같은 시나리오들에 대한 테스트를 쉽게 만들 수 있다:

- 저장된 자격(credentials)을 불러온다 -> 존재한다면 인증을 시도한다 -> 성공하면 메인 화면으로 이동한다.
- 저장된 자격(credentials)을 불러온다 -> 존재하지 않는다면 프로그레스 바를 숨기고 로그인 폼을 보여준다.
- 저장된 자격(credentials)을 불러온다 -> 존재한다면 인증을 시도한다 -> 인증에 오류가 있으면 프로그레스바를 멈추고 오류를 보여준다.

첫 번째 시나리오로 구현해보자.

    @Test
    fun initWithSavedLogin_HaveSavedCredentials_LoginOk() {
      //login screen init and look for saved credentials in preferences
      var initState = LoginPresenter.LoginState()
      //update
      val (searchForLoginState, searchForLoginCmd) = presenter.update(Init(), initState)
    
      assertEquals(initState.copy(isLoading = true), searchForLoginState)
      assertThat(searchForLoginCmd, instanceOf(LoginPresenter.GetSavedUserCmd::class.java))
    
      //render
      presenter.render(searchForLoginState)
      verify(view).showProgress()
      verify(view).disableLoginBtn()
      verify(view).hideLoginError()
      verify(view).hidePasswordError()
      verify(view).hideError()
      verifyNoMoreInteractions(view)
      
      Mockito.`when`(prefs.getUserSavedCredentials())
        .thenReturn(Single.just(Pair("login", "password")))
      
      //call
      val loadedCredentialsMsg = presenter.call(searchForLoginCmd)
    
      //credentials loaded and start auth http call
      //update
      val (startAuthState, startAuthCmd) = presenter.update(loadedCredentialsMsg.blockingGet(), searchForLoginState)
      assertEquals((searchForLoginState as LoginPresenter.LoginState).copy(login = "login", pass = "password"), startAuthState)
      assertThat(startAuthCmd, instanceOf(LoginPresenter.LoginCmd::class.java))
      assertEquals("login", (startAuthCmd as LoginPresenter.LoginCmd).login)
      assertEquals("password", startAuthCmd.pass)
    
      Mockito.reset(view)
      //render
      presenter.render(startAuthState)
      verify(view).showProgress()
      verify(view).disableLoginBtn()
      verify(view).hideLoginError()
      verify(view).hidePasswordError()
      verify(view).hideError()
      verifyNoMoreInteractions(view)
    
      Mockito.`when`(loginService.login("login", "password"))
        .thenReturn(Single.just(true))
      //call
      val authOkMsg = presenter.call(startAuthCmd)
    
      //auth OK, go to main screen
      //update
      val (loggedState, noneCmd) = presenter.update(authOkMsg.blockingGet(), startAuthState)
      assertThat(noneCmd, instanceOf(None::class.java))
    
      Mockito.reset(view)
      //render
      presenter.render(loggedState)
      verify(view).goToMainScreen()
      verify(view).hideKeyboard()
      verifyNoMoreInteractions(view)
    }

결론

첫 두 개의 포스트에서 Elm 아키텍처 패턴을 presentation layer 또는 presenter에 직접 구현함으로서 UI 로직을 놀랍도록 예측 가능하고 테스트 가능하게 할 수 있음을 보여주었다. 더욱이 TEA는 당신이 UI를 위한 로직을 작성하는 방식을 바꾼다. 이벤트들과 외부 효과들을 분리함으로서 TEA는 당신이 UI를 전이들과 상태들을 가진 상태 머신으로 생각하도록 자극한다.

Thanks for reading, I hope you enjoyed it!

If you want to discuss, follow to Reddit post

and follow me on twitter to get updates about my new posts
