---
layout: post
category: blog
title: 'Dagger 가이드 #1'
date: '2016-06-15 15:20:00 +0900'
categories: designpatter
published: true
tags:
  - dagger
---

[원본](http://google.github.io/dagger/users-guide)

어떤 애플리케이션에서 최고의 클래스들은 자기 할 일을 하는 클래스들이다 : BarcodeDecoder, KoopaPhysicsEngine, 그리고 AudioStreamer. 이 클래스들은 의존(dependency)들을 가지고 있다; 아마 BarcodeCameraFinder, DefaultPhysicsEngine, 그리고 HttpStreamer같은 것들일 것이다.

반대로, 어떤 애플리케이션에서 최악의 클래스들은 하는 일이 전혀 없이 공간을 차지하는 것들이다 : BarcodeDecodeFactory, CameraServiceLoader, MutableContextWrapper. 이 클래스들은 관심의 대상들을 묶어주는 투박한 박스 테이프이다.

Dagger는 이러한 FactoryFactory 클래스들의 대체품이다. Dagger는 boilerplate 코드 작성에 대한 부담없이 [의존성 주입](https://en.wikipedia.org/wiki/Dependency_injection) 디자인 패턴을 구현한다. Dagger는 관심의 대상인 클래스들에 초점을 맞출 수 있게 해준다. 의존 관계(dependency)들을 선언하고, 어떻게 만족시킬지를 명시한 다음 애플리케이션을 출시하면 된다.

[javax.inject](http://docs.oracle.com/javaee/7/api/javax/inject/package-summary.html) 어노테이션([JSR 330](https://jcp.org/en/jsr/detail?id=330))을 기반으로 하였기에 각각의 **클래스는 테스트하기 수월하다**. RpcCreditCardService을 FakeCreditCardService으로 교환하는 것만을 위한 boilerplate 코드는 필요하지 않는다.

의존성 주입은 테스트만을 위한 것이 아니다. Dagger는 **재사용 가능하고, 교체 가능한** 모듈을 만들기 쉽게 해준다. 당신은 앱 전체에 동일한 AuthenticationModule을 공유할 수 있다. 그리고 각 상황에 적절한 행동을 얻기 위해 개발에서는 DevLoggingModule을 실행하고 운영에서는 ProdLoggingModule을 실행 할 수도 있다.

# 왜 Dagger 2는 다른가?

[의존성 주입](https://en.wikipedia.org/wiki/Dependency_injection) 프래임워크는 주입(injecting)과 설정(configuring)을 위한 온갖 종류의 다양한 API들과 함께 오래전부터 존재하고 있다. 그런데, 왜 바퀴를 다시 만드는가? **전체 스택을 자동으로 생성된 코드로 구현하도록 한 것은** Dagger 2가 처음이다. 사용자가 손으로 의존성 주입이 가능한 한 간단하고, 추적 가능하며(traceable) 성능을 보장하도록 작성하였을 듯한 코드를 흉내낸 코드를 생성하는 것이 지도 원칙(guiding principle)이다. 디자인에 대한 더 많은 배경은 [+Gregory Kick](https://plus.google.com/+GregoryKick/posts)의 [강연]((https://www.youtube.com/watch?v=oK_XtfXPkqw&feature=youtu.be))([슬라이드](https://docs.google.com/presentation/d/1fby5VeGU9CN8zjw4lAb2QPPsKRxx6mSwCe9q7ECNSJQ/pub?start=false&loop=false&delayms=3000&slide=id.p))을 보라.

# Dagger 사용하기

우리는 커피 메이커를 만들면서 의존성 주입과 Dagger의 작동 과정을 보여 줄 것이다. 컴파일되고 실행할 수 있는 완전한 샘플 코드는 Dagger의 [커피 예제](https://github.com/google/dagger/tree/master/examples/simple/src/main/java/coffee)를 보라.

## 의존(dependency)을 선언하기.

Dagger는 당신 애플리케이션의 클래스들의 인스턴스들을 생성하고(construct) 그들의 의존(dependency)을 만족시킨다. Dagger가 관심을 가져야 할 필드들과 생성자들을 식별하기 위해 [javax.inject.Inject](http://docs.oracle.com/javaee/7/api/javax/inject/Inject.html) 어노테이션을 사용한다.

Dagger가 클래스의 인스턴스를 생성하기 위해 사용할 생성자에 @Inject 어노테이션를 사용하라. 새로운 인스턴스가 요청되면, Dagger는 필수 파라미터들의 값들을 획득한 뒤 이 생성자를 호출할 것이다.
(역: Dagger는 아래 Thermosiphon을 생성하기 위해 Heater를 인스턴스를 생성한 다음 그 인스턴스를 Thremosiphon의 @Inject 어노테이트된 생성자에 전달하여 Thremosiphon의 인스턴스를 생성한다.)

    class Thermosiphon implements Pump {
      private final Heater heater;

      @Inject
      Thermosiphon(Heater heater) {
        this.heater = heater;
      }

      ...
    }

Dagger는 필드에 직접 주입할 수 있다. 이 예제에서 Dagger는 heater 필드를 위해 Heater 인스턴스를, pump 필드를 위해 Pump 인스턴스를 획득한다.

    class CoffeeMaker {
      @Inject Heater heater;
      @Inject Pump pump;

      ...
    }

만약 당신의 클래스가 @Inject 어노테이션된 필드를 가지고 있지만 @Inject 어노테이션된 생성자는 없다면 Dagger는 요청을 받았을 때 당신의 클래스의 필드들에는 주입하여 줄 것이지만 당신의 클래스의 새로운 인스턴스를 생성하여 주지는 않을 것이다. Dagger에게 인스턴스도 생성하여야 한다는 것을 알려주기 위해서는 인수가 없는 @Inject 어노테이션된 생성자를 추가하라.

보통 생성자나 필드 주입이 더 선호되지만 Dagger는 method 주입도 지원한다.
(역: Dagger가 생성하는 코드를 보면 순서가 1. @Inject어노테이트된 생성자의 파라미터들의 값을 획득, 2. 생성자에 값을 전달하여 인스턴스를 생성 3. 생성된 인스턴스에 @Inject어노테이트된 멤버들을 주입 4. @Inject어노테이트된 메소드의 파라미터의 값들을 획득한 뒤 그 값을 넘겨주면서 메소드를 호출)

@Inject 어노테이션이 누락된 클래스는 Dagger에 의해 생성될 수 없다.

## 의존(dependency)들을 만족시키기

기본적으로, Dagger는 위에서 설명한 것처럼 요청된 타입의 인스턴스를 생성하여 각각의 의존(의존성,dependency)을 만족시킨다. 당신이 CoffeMaker를 요청하면, new CoffeeMaker() 호출을 통해 한 인스턴스를 얻고 주입 가능한 필드들에 놓는다.

하지만 @Inject가 어디서나 동작하지는 않는다 :

* 인터페이스를 생성할 수 없다.
* Third-party 클래스들에는 어노테이션을 추가할 수 없다.
* 설정할 수 있는 객체들은 설정되어야 한다!

@Inject가 불충분하거나 곤란한 경우, 의존(dependency)을 만족하기 위해 [@Provides](http://google.github.io/dagger/api/latest/dagger/Provides.html)-어노테이션 메소드를 사용하라. 이 메소드의 반환 타입은 어떤 의존(dependency)을 만족시킬지를 정의한다.

예를 들어, provideHeater()은 Heater가 요청될 때 마다 호출된다:

    @Provides static Heater provideHeater() {
      return new ElectricHeater();
    }

@Provides 메소드가 자신의 의존(dependency)을 가지는 것이 가능한다. 이것은 Pump가 요청될 때마다 Thermosiphon을 반환한다:

    @Provides static Pump providePump(Thermosiphon pump) {
      return pump;
    }

모든 @Provides 메소드들은 module에 속해있어야 한다. 이것은 단지 [@Module](http://google.github.io/dagger/api/latest/dagger/Module.html) 어노테이션을 가진 클래스들이다.

    @Module
    class DripCoffeeModule {
      @Provides static Heater provideHeater() {
        return new ElectricHeater();
      }

      @Provides static Pump providePump(Thermosiphon pump) {
        return pump;
      }
    }

관습에 따라, @Provides 메소드들은 앞에 provide가 붙은 이름을 가져야 하며 module 클래스들은 마지막에 Module가 붙은 이름을 가져야 한다.

## 그래프 만들기

@Inject와 @Provides 어노테이션된 클래스들은 그들의 의존들(dependencies)로 연결된, 객체들의 그래프를 형성한다. 애플리케이션의 main 메소드나 Android [Application](http://developer.android.com/reference/android/app/Application.html)같은 호출 코드는 잘 정의된 기원 집합(roots of set)을 통해 그 그래프에 접근한다. Dagger2에서 그 집합(set)은 인수(argument)를 가지지 않으며 요구하는 타입을 반환하는 메소드를 가진 인터페이스에 의해 정의된다. 그런 인터페이스에 [@Component](http://google.github.io/dagger/api/latest/dagger/Component.html) 어노테이션을 적용하고 modules 파라미터에 [module](http://google.github.io/dagger/api/latest/dagger/Module.html) 타입들을 전달하면, Dagger2는 그 계약의 구현을 완전히 생성한다.

    @Component(modules = DripCoffeeModule.class)
    interface CoffeeShop {
      CoffeeMaker maker();
    }

이것의 구현은 인터페이스의 이름 앞에 'Dagger'를 추가한 이름을 가진다. 그것의 구현에 있는 builder() 메소드를 호출해 인스턴스를 얻는다. 그리고 의존들을 설정하기 위해 반환된 [builder](https://en.wikipedia.org/wiki/Builder_pattern)를 사용한 뒤 build()로 새로운 인스턴스를 만든다.

    CoffeeShop coffeeShop = DaggerCoffeeShop.builder()
        .dripCoffeeModule(new DripCoffeeModule())
        .build();

Note: 만약 당신의 @Component가 최상위 타입이 아니라면, 생성된 component의 이름은 밑줄(underscore)로 연결된 외부(enclosing) 타입들의 이름들을 포함할 것이다. 예를 들어 이 코드는:

    class Foo {
      static class Bar {
        @Component
        interface BazComponent {}
      }
    }

DaggerFoo_Bar_Baz라는 이름을 가진 component를 생성할 것이다.

기본 생성자로 접근가능한 모듈은 설정할 것이 없다면 builder가 자동으로 인스턴스를 생성할 것이므로 생략할 수 있다. 그리고 @provides 메소드가 모두 static인 모듈을 위해 구현은 인스턴스를 전혀 필요로 하지 않는다. 만약 모든 의존들이 사용자가 의존(dependency) 인스턴스를 생성하지 않고
만약 모든 의존들이 사용자가 의존(dependency)의 인스턴스를 생성하지 않고 생성될 수 있다면, 생성된 구현은 builder를 다루지 않고 새로운 인스턴스를 얻기 위해 사용할 수 있는 create() 메소드를 가질 것이다.

    CoffeeShop coffeeShop = DaggerCoffeeShop.create();
    Now, our CoffeeApp can simply use the Dagger-generated implementation of CoffeeShop to get a fully-injected CoffeeMaker.

    public class CoffeeApp {
      public static void main(String[] args) {
        CoffeeShop coffeeShop = DaggerCoffeeShop.create();
        coffeeShop.maker().brew();
      }
    }

그래프가 생성되고 진입점은 주입되었으니, coffer maker 앱을 실행한다. Fun.

    $ java -cp ... coffee.CoffeeApp
    ~ ~ ~ heating ~ ~ ~
    => => pumping => =>
    [_]P coffee! [_]P

# 그래프의 바인딩들

위의 예제는 일반적인 바인딩의 일부만을 가진 component를 생성하는 방법을 보여준다. 그래프에 바인딩을 제공하기 위한 다양한 방식들이 있다. 다음은 의존으로 이용할 수 있으며 규칙에 맞는 component를 생성하기 위해 사용될 것이다:

* Those declared by @Provides methods within a @Module referenced directly by @Component.modules or transitively via @Module.includes
* Any type with an @Inject constructor that is unscoped or has a @Scope annotation * that matches one of the component’s scopes
* The component provision methods of the component dependencies
* The component itself
* Unqualified builders for any included subcomponent
* Provider or Lazy wrappers for any of the above bindings
* A Provider of a Lazy of any of the above bindings (e.g., * Provider<Lazy<CoffeeMaker>>)
* A MembersInjector for any type


## 싱글톤들과 Scoped 바인딩들

Annotate an @Provides method or injectable class with @Singleton. The graph will use a single instance of the value for all of its clients.

    @Provides @Singleton static Heater provideHeater() {
      return new ElectricHeater();
    }

The @Singleton annotation on an injectable class also serves as documentation. It reminds potential maintainers that this class may be shared by multiple threads.

    @Singleton
    class CoffeeMaker {
      ...
    }
    
Since Dagger 2 associates scoped instances in the graph with instances of component implementations, the components themselves need to declare which scope they intend to represent. For example, it wouldn’t make any sense to have a @Singleton binding and a @RequestScoped binding in the same component because those scopes have different lifecycles and thus must live in components with different lifecycles. To declare that a component is associated with a given scope, simply apply the scope annotation to the component interface.

    @Component(modules = DripCoffeeModule.class)
    @Singleton
    interface CoffeeShop {
      CoffeeMaker maker();
    }
    
Components may have multiple scope annotations applied. This declares that they are all aliases to the same scope, and so that component may include scoped bindings with any of the scopes it declares.

## Reusable scope

Sometimes you want to limit the number of times an @Inject-constructed class is instantiated or a @Provides method is called, but you don’t need to guarantee that the exact same instance is used during the lifetime of any particular component or subcomponent. This can be useful in environments such as Android, where allocations can be expensive.

For these bindings, you can apply @Reusable scope. @Reusable-scoped bindings, unlike other scopes, are not associated with any single component; instead, each component that actually uses the binding will cache the returned or instantiated object.

That means that if you install a module with a @Reusable binding in a component, but only a subcomponent actually uses the binding, then only that subcomponent will cache the binding’s object. If two subcomponents that do not share an ancestor each use the binding, each of them will cache its own object. If a component’s ancestor has already cached the object, the subcomponent will reuse it.

There is no guarantee that the component will call the binding only once, so applying @Reusable to bindings that return mutable objects, or objects where it’s important to refer to the same instance, is dangerous. It’s safe to use @Reusable for immutable objects that you would leave unscoped if you didn’t care how many times they were allocated.

    @Reusable // It doesn't matter how many scoopers we use, but don't waste them.
    class CoffeeScooper {
      @Inject CoffeeScooper() {}
    }

    @Module
    class CashRegisterModule {
      @Provides
      @Reusable // DON'T DO THIS! You do care which register you put your cash in.
                // Use a specific scope instead.
      static CashRegister badIdeaCashRegister() {
        return new CashRegister();
      }
    }


    @Reusable // DON'T DO THIS! You really do want a new filter each time, so this
              // should be unscoped.
    class CoffeeFilter {
      @Inject CoffeeFilter() {}
    }

## Lazy injections

Sometimes you need an object to be instantiated lazily. For any binding T, you can create a Lazy<T> which defers instantiation until the first call to Lazy<T>’s get() method. If T is a singleton, then Lazy<T> will be the same instance for all injections within the ObjectGraph. Otherwise, each injection site will get its own Lazy<T> instance. Regardless, subsequent calls to any given instance of Lazy<T> will return the same underlying instance of T.

    class GridingCoffeeMaker {
      @Inject Lazy<Grinder> lazyGrinder;

      public void brew() {
        while (needsGrinding()) {
          // Grinder created once on first call to .get() and cached.
          lazyGrinder.get().grind();
        }
      }
    }

## Provider injections

Sometimes you need multiple instances to be returned instead of just injecting a single value. While you have several options (Factories, Builders, etc.), one option is to inject a Provider<T> instead of just T. A Provider<T> invokes the binding logic for T each time .get() is called. If that binding logic is an @Inject constructor, a new instance will be created, but a @Provides method has no such guarantee.

    class BigCoffeeMaker {
      @Inject Provider<Filter> filterProvider;

      public void brew(int numberOfPots) {
      ...
        for (int p = 0; p < numberOfPots; p++) {
          maker.addFilter(filterProvider.get()); //new filter every time.
          maker.addCoffee(...);
          maker.percolate();
          ...
        }
      }
    }

Note: Injecting Provider<T> has the possibility of creating confusing code, and may be a design smell of mis-scoped or mis-structured objects in your graph. Often you will want to use a factory or a Lazy<T> or re-organize the lifetimes and structure of your code to be able to just inject a T. Injecting Provider<T> can, however, be a life saver in some cases. A common use is when you must use a legacy architecture that doesn’t line up with your object’s natural lifetimes (e.g. servlets are singletons by design, but only are valid in the context of request-specfic data).

## Qualifiers

Sometimes the type alone is insufficient to identify a dependency. For example, a sophisticated coffee maker app may want separate heaters for the water and the hot plate.

In this case, we add a qualifier annotation. This is any annotation that itself has a @Qualifier annotation. Here’s the declaration of @Named, a qualifier annotation included in javax.inject:

    @Qualifier
    @Documented
    @Retention(RUNTIME)
    public @interface Named {
      String value() default "";
    }

You can create your own qualifier annotations, or just use @Named. Apply qualifiers by annotating the field or parameter of interest. The type and qualifier annotation will both be used to identify the dependency.

    class ExpensiveCoffeeMaker {
      @Inject @Named("water") Heater waterHeater;
      @Inject @Named("hot plate") Heater hotPlateHeater;
      ...
    }

Supply qualified values by annotating the corresponding @Provides method.

    @Provides @Named("hot plate") static Heater provideHotPlateHeater() {
      return new ElectricHeater(70);
    }

    @Provides @Named("water") static Heater provideWaterHeater() {
      return new ElectricHeater(93);
    }

Dependencies may not have multiple qualifier annotations.

## Compile-time Validation

The Dagger annotation processor is strict and will cause a compiler error if any bindings are invalid or incomplete. For example, this module is installed in a component, which is missing a binding for Executor:

    @Module
    class DripCoffeeModule {
      @Provides static Heater provideHeater(Executor executor) {
        return new CpuHeater(executor);
      }
    }

When compiling it, javac rejects the missing binding:

    [ERROR] COMPILATION ERROR :
    [ERROR] error: java.util.concurrent.Executor cannot be provided without an @Provides-annotated method.
    Fix the problem by adding an @Provides-annotated method for Executor to any of the modules in the component. While @Inject, @Module and @Provides annotations are validated individually, all validation of the relationship between bindings happens at the @Component level. Dagger 1 relied strictly on @Module-level validation (which may or may not have reflected runtime behavior), but Dagger 2 elides such validation (and the accompanying configuration parameters on @Module) in favor of full graph validation.

## Compile-time Code Generation

Dagger’s annotation processor may also generate source files with names like CoffeeMaker_Factory.java or CoffeeMaker_MembersInjector.java. These files are Dagger implementation details. You shouldn’t need to use them directly, though they can be handy when step-debugging through an injection. The only generated types you should refer to in your code are the ones Prefixed with Dagger for your component.

# Using Dagger In Your Build

## Gradle Users

You will need to include the dagger-2.2.jar in your application’s runtime. In order to activate code generation you will need to include dagger-compiler-2.2.jar in your build at compile time.

In a Maven project, one would include the runtime in the dependencies section of your pom.xml, and the dagger-compiler artifact as a dependency of the compiler plugin:

    <dependencies>
      <dependency>
        <groupId>com.google.dagger</groupId>
        <artifactId>dagger</artifactId>
        <version>2.2</version>
      </dependency>
      <dependency>
        <groupId>com.google.dagger</groupId>
        <artifactId>dagger-compiler</artifactId>
        <version>2.2</version>
        <optional>true</optional>
      </dependency>
    </dependencies>

